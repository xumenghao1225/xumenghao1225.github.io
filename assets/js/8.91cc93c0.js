(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{322:function(s,t,a){"use strict";a.r(t);var n=a(7),r=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h3",{attrs:{id:"虚拟dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[s._v("#")]),s._v(" 虚拟DOM")]),s._v(" "),t("p",[s._v("虚拟DOM其实一种通过js生成的AST的节点树，也可以称为真正的树形结构。"),t("br"),s._v("\n在这之前我们还要了解什么是dom树，下面是浏览器解析页面时的流程：")]),s._v(" "),t("div",{staticClass:"language-javascript line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1.")]),s._v(" 解析html：解析html文档，并构建dom树"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// DOM 树表示 HTML 文档中元素之间的层次关系。")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2.")]),s._v(" 解析css：解析css样式"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("并构建cssom树"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// CSSOM 树表示样式之间的层次关系和作用范围。")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3.")]),s._v(" 生成渲染树：浏览器将dom树喝cssom树合并，生成渲染树，渲染树包含了所有需要渲染的元素以及元素的样式信息"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("但不包含不需要渲染的元素"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4.")]),s._v(" 布局：浏览器遍历渲染树，计算每个元素的位置和大小等布局信息，生成布局树"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5.")]),s._v(" 绘制：浏览器遍历布局树，将每个元素绘制到屏幕上，生成位图"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("6.")]),s._v(" 合成：浏览器将位图按照z"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("index顺序合成图层，最终显示在屏幕上。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("p",[s._v("如果使用原生js或者jq的操作dom的话，每次都会引发dom的重流与重绘。"),t("br"),s._v("\n虚拟dom就是为了解决这个问题而出现的，对比每次更新(diff)的内容，然后更新的节点内容更新到dom上。"),t("br"),s._v("\n所以，用 JS 对象模拟 DOM 节点的好处是，页面的更新可以先全部反映在 JS 对象(虚拟 DOM )上，操作内存中的 JS 对象的速度显然要更快，等更新完成后，再将最终的 JS 对象映射成真实的 DOM，交由浏览器去绘制。")]),s._v(" "),t("h3",{attrs:{id:"diff算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#diff算法"}},[s._v("#")]),s._v(" diff算法")]),s._v(" "),t("blockquote",[t("p",[s._v("Virtual DOM 渲染成真实的 DOM 实际上要经历 VNode 的定义、diff、patch 等过程;\n这些过程要么保留原始节点，要么移动节点。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);